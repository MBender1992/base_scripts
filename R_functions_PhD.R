
##################################################
# This script contains several useful functions  #
# for the analysis of chronic irradiated SCC     #
# cell lines for my PhD                          #
##################################################




######################################################
#                                                    #
# 1. Functions to ingest data in a reproducible way  #
#                                                    #
######################################################

load_Fireplex_data_PhD <- function(filename = "200619_chronic_irr_normalized.csv", threshold)
{
  # check if required package is installed and load it
  if (!require(dplyr)) install.packages("dplyr")
  library(dplyr)
  
  #load data and change hyphens to underscores so r does not confuse a hyphen with minus
  dat <- read_csv(filename)
  names(dat) <- str_replace_all(names(dat), "-","_")
  # clean up the data, convert to tidy format and replace negative expression values with 0 as expression cannot be negative
  dat_f <- dat %>% 
    select(-Messung) %>%
    filter(cell_line != "HaCaT") %>%
    gather(miRNA, expression, -c(ID,cell_line, Irradiation)) %>% 
    mutate(expression = ifelse(expression < 0, 0, expression))  
  # index miRNAs with a median expression below the threshold
  ind <- dat_f %>%
    group_by(miRNA) %>%
    filter(median(expression, na.rm=TRUE) <= threshold) %>%
    .$miRNA %>% 
    unique() 
  # omit indexed miRNAs 
  dat_f %>% 
    filter(!miRNA %in% ind) %>%
    mutate(log_exp = log2(expression+1)) %>%
    mutate(miRNA = str_replace_all(miRNA, "hsa_", "")) %>%
    mutate(miRNA = str_replace_all(miRNA, "_","-")) %>%
    mutate(cell_line = str_replace_all(cell_line, "-","_"))
}

######################################################
#                                                    #
#        2. Data manipulation                        #
#                                                    #
######################################################

# ..................................................................................................................
# this function is used to extract clusters from a Heatmap object generated with ComplexHeatmap #

# Arguments                                                                                             #
#  - data: scaled data which was the iput to generate Heatmap                                           #
#  - HeatmapObj: Heatmap object generated with the Heatmap() function of the ComplexHeatmap package     #
#  - sampleName: Name of the column containing sample IDs                                               #
#  - sampleClust: Name of the clusters generated by clustering the samples (columns in the Heatmap)     #
#  - geneName: Name of the column containing genes/miRNAs                                               #
#  - geneClust: Name of the clusters generated by clustering the genes/miRNAs (rows in the Heatmap)     #

extract_clusters <- function(data, HeatmapObj, sampleName, sampleClust, geneName, geneClust){
  mat <- data
  # loops to extract samples (columns) from the cluster
  for (i in 1:length(column_order(HeatmapObj))){   if (i == 1) {
    clu <- t(t(colnames(mat[,column_order(HeatmapObj)[[i]]])))
    out <- cbind(clu, paste(toupper(letters[i])))
    colnames(out) <- c(sampleName, sampleClust)   } else {
      clu <- t(t(colnames(mat[,column_order(HeatmapObj)[[i]]])))
      clu <- cbind(clu, paste(toupper(letters[i])))
      out <- rbind(out, clu)   } 
  }
  colClust <- as.data.frame(out) 
  
  # function to extract miRNAs/genes (rows) from the cluster
  for (i in 1:length(row_order(Ht))){   if (i == 1) {
    clu <- t(t(rownames(mat[row_order(Ht)[[i]],])))
    out <- cbind(clu, paste("cluster", i, sep=""))
    colnames(out) <- c(geneName, geneClust)     } else {
      clu <- t(t(rownames(mat[row_order(Ht)[[i]],])))
      clu <- cbind(clu, paste("cluster",i, sep=""))
      out <- rbind(out, clu)    } 
  }
  rowClust <- as.data.frame(out)
  
  res <- list(colClust,rowClust)
  names(res) <- c(sampleClust, geneClust)
  return(res)
}



# ..................................................................................................................
# this function is used to calculate fold changes and pvalues in clusters extracted out of Heatmap #

# Function to extract fold changes and p-values of clusters
summary_clusters <- function(ls, miRcluster, cellcluster){
  # filter data for miRNA cluster i and combine data from cell cluster B and C as we wanna compare cluster A to the rest as the Heatmap indicates upregulation
  data <- ls[[miRcluster]] %>%
    mutate(cellCluster = ifelse(cellCluster == cellcluster, cellcluster, "ref")) %>%
    select(-miRCluster)
  # calculate FoldChange of the specified cluster vs the rest
  FC <- data %>%
    group_by(miRNA, cellCluster) %>%
    summarize(mean = mean(log_exp)) %>%
    ungroup() %>%
    group_by(miRNA) %>%
    summarize(logFC = mean[cellCluster==cellcluster]-mean[cellCluster =="ref"])
  # calculate pvalues 
  p_val <- data %>% 
    group_by(miRNA) %>%
    t_test(log_exp~cellCluster) %>%
    adjust_pvalue(method = "fdr")
  joined <- left_join(p_val, FC) %>% 
    mutate(FC = 2^logFC) %>%
    select(c(miRNA,FC, p.adj)) %>%
    setNames(c("miRNA", "FC","pvalue"))
  return(joined)
}



# ..................................................................................................................
# this function is used to drop attributes of a list #
drop_attr <- function(x) {
  for (i in length(x)) attr(x[[i]], "names") <- NULL
  return(x)
}


######################################################
#                                                    #
#        3. Plotting and significance Tests          #
#                                                    #
######################################################


# ..................................................................................................................
# this function is used to ensure a uniform theme and layout is used in each plot #

# Arguments                                                     #
#  - axis.text.size: Size of the axes                           #
#  - Legend: logical indicating if legend should be printed     #
theme_PhD <- function(axis.text.size=10, Legend = TRUE,...){
  
  theme_custom <- theme_pubr()+
    theme(axis.title.x=element_blank(),
          axis.text.x = element_text(face = "bold", size=axis.text.size),
          axis.text.y = element_text(face = "bold", size=axis.text.size),
          axis.title.y = element_text(face = "bold", size = axis.text.size+1),
          panel.grid.minor=element_blank(),
          strip.text.x = element_text(face = "bold", size = axis.text.size+1),
          strip.background=element_blank(),
          panel.spacing = unit(1, "lines"), ...) 
  
  
  if(Legend == TRUE) {
    theme_custom + theme(legend.key.size = unit(1,"line"))
  } else {
    theme_custom + theme(legend.position = "none")
  }
}

# ..................................................................................................................


######################################################
#                                                    #
#                   4. Misc                          #
#                                                    #
######################################################


# function from RBiomiRGS package, without storing results in csv files for less storage usage
rbiomirgs_mrnascan_custom <- function (objTitle = "miRNA", mir = NULL, sp = "hsa", 
                                     addhsaEntrez = FALSE, queryType = NULL, predictPercentage = 10, 
                                     url = "http://multimir.org/cgi-bin/multimir_univ.pl", 
                                     parallelComputing = FALSE, clusterType = "PSOCK") 
{
  if (is.null(mir)) 
    stop("Please set the input miRNA(s). Either single targets or a vector of mutliple ones can be used.")
  if (!is.null(dim(mir))) 
    stop("The input argument mir needs to be a vector. ")
  if (!sp %in% c("hsa", "mmu", "rno")) {
    stop(cat("Only human, mouse or rat are supported for now. Please choose either \"hsa\" (default), \"mmu\", or \"rno\" for species."))
  }
  if (sp == "hsa" && addhsaEntrez) {
    cat("Argument addhsaEntrez automatically set to FALSE when sp = \"hsa\".\n")
    addhsaEntrez = FALSE
  }
  if (is.null(queryType)) {
    stop(cat("Please set the queryType argument. Options are \"validated\" and \"predicted\"."))
  }
  else if (queryType != "validated" & queryType != "predicted") {
    stop(cat("queryType only takes \"validated\" or \"predicted\". Check the spell."))
  }
  else if (queryType == "validated") {
    db <- c("mirecords", "mirtarbase", "tarbase")
  }
  else if (queryType == "predicted") {
    if (sp == "rno") {
      db <- c("elmmo", "microcosm", "miranda", 
              "mirdb")
    }
    else {
      db <- c("diana_microt", "elmmo", "microcosm", 
              "miranda", "mirdb", "pictar", 
              "pita", "targetscan")
    }
  }
  tmpfunc_q <- function(i, j, mode = NULL, percentage = NULL) {
    target.table <- "target"
    mirna.table <- "mirna"
    tmpmirna <- i
    tmpmirna <- paste(tmpmirna, collapse = "','")
    tmpmirna <- paste("('", tmpmirna, "')", sep = "")
    if (mode == "validated") {
      q <- paste("SELECT m.mature_mirna_id,", "t.target_symbol, t.target_entrez, t.target_ensembl,", 
                 "i.experiment, i.pubmed_id FROM", mirna.table, 
                 "AS m INNER JOIN", j, "AS i INNER JOIN", 
                 target.table, "AS t ON (m.mature_mirna_uid=i.mature_mirna_uid AND", 
                 "i.target_uid=t.target_uid) WHERE", sep = " ")
      q <- paste(q, "(m.mature_mirna_acc IN", tmpmirna, 
                 "OR m.mature_mirna_id IN", tmpmirna, ")", 
                 sep = " ")
      q <- paste(q, " AND m.org = '", sp, "' AND t.org = '", 
                 sp, "'", sep = "")
    }
    else {
      tmpfunc_cutoff <- function(cutoff.file = "http://multimir.ucdenver.edu/multimir_cutoffs.rda") {
        multimir_cutoffs <- NULL
        url.file <- url(cutoff.file)
        on.exit(close(url.file))
        load(url.file)
        return(multimir_cutoffs)
      }
      q <- paste("SELECT m.mature_mirna_acc, m.mature_mirna_id,", 
                 "t.target_symbol, t.target_entrez, t.target_ensembl FROM", 
                 mirna.table, "AS m INNER JOIN", j, "AS i INNER JOIN", 
                 target.table, "AS t ON (m.mature_mirna_uid=i.mature_mirna_uid", 
                 "AND i.target_uid=t.target_uid) WHERE", 
                 sep = " ")
      if (j == "diana_microt") {
        q <- sub(" FROM ", ", i.miTG_score AS score FROM ", 
                 q)
      }
      else if (j == "elmmo") {
        q <- sub(" FROM ", ", i.p AS score FROM ", 
                 q)
      }
      else if (j %in% c("microcosm", "mirdb", 
                        "pictar")) {
        q <- sub(" FROM ", ", i.score FROM ", 
                 q)
      }
      else if (j == "miranda") {
        q <- sub(" FROM ", ", i.mirsvr_score AS score FROM ", 
                 q)
      }
      else if (j == "pita") {
        q <- sub(" FROM ", ", i.ddG AS score FROM ", 
                 q)
      }
      else if (j == "targetscan") {
        q <- sub(" FROM ", ", i.context_plus_score AS score FROM ", 
                 q)
      }
      q <- paste(q, "(m.mature_mirna_acc IN", tmpmirna, 
                 "OR m.mature_mirna_id IN", tmpmirna, ")", 
                 sep = " ")
      q <- paste(q, " AND m.org = '", sp, "' AND t.org = '", 
                 sp, "'", sep = "")
      nm <- paste(j, sp, sep = ".")
      tmp_cutoff <- tmpfunc_cutoff()
      cutoff <- tmp_cutoff[[nm]][[paste(percentage, "%", 
                                        sep = "")]]
      if (j == "diana_microt") {
        q <- paste(q, "AND i.miTG_score >=", cutoff, 
                   "ORDER BY i.miTG_score DESC", sep = " ")
      }
      else if (j == "elmmo") {
        q <- paste(q, "AND i.p >=", cutoff, "ORDER BY i.p DESC", 
                   sep = " ")
      }
      else if (j %in% c("microcosm", "mirdb", 
                        "pictar")) {
        q <- paste(q, "AND i.score >=", cutoff, 
                   "ORDER BY i.score DESC", sep = " ")
      }
      else if (j == "miranda") {
        q <- paste(q, "AND i.mirsvr_score <=", 
                   cutoff, "ORDER BY i.mirsvr_score", sep = " ")
      }
      else if (j == "pita") {
        q <- paste(q, "AND i.ddG <=", cutoff, "ORDER BY i.ddG", 
                   sep = " ")
      }
      else if (j == "targetscan") {
        q <- paste(q, "AND i.context_plus_score <=", 
                   cutoff, "ORDER BY i.context_plus_score", 
                   sep = " ")
      }
    }
    tmprslt <- postForm(url, query = q, .cgifields = c("query"))
    tmprslt <- readHTMLTable(tmprslt)
    tmpout <- NULL
    l <- length(tmprslt)
    if (l == 2) {
      tmpout <- tmprslt[[2]]
    }
    else if (l == 1) {
      warning(paste("No records returned for miRNA: ", 
                    i, " in database: ", j, ".", sep = ""))
    }
    else if (l == 0) {
      cat(paste("Request to multiMiR web server failed. check the ", 
                "your query, or", "use the multiMiR web server:", 
                "http://multimir.ucdenver.edu is temporarily down.\n"))
    }
    if (!is.null(tmpout)) {
      tmpout <- data.frame(database = j, tmpout, stringsAsFactors = FALSE)
    }
    return(tmpout)
  }
  tmpfunc_lst <- function(x) {
    if (!is.null(x)) {
      y <- as.character(unique(x$target_entrez))
      y[y == ""] <- NA
      y <- y[!is.na(y)]
      y <- unique(y)
    }
    else {
      y <- NA
    }
    return(y)
  }
  out <- vector(mode = "list", length = length(mir))
  names(out) <- mir
  out_entrez <- vector(mode = "list", length = length(mir))
  names(out_entrez) <- mir
  if (addhsaEntrez) {
    cat(paste("Obtaining hsa orthologs information from ensembl databases for ", 
              sp, "... May be slow depending on internet connectivity...", 
              sep = ""))
    if (sp == "mmu") {
      martsp <- "mmusculus"
    }
    else if (sp == "rno") {
      martsp <- "rnorvegicus"
    }
    martsp_ensembl <- useMart("ensembl", dataset = paste0(martsp, 
                                                          "_gene_ensembl"))
    attr <- c("ensembl_gene_id", "hsapiens_homolog_ensembl_gene")
    martsp_hsa_orth <- getBM(attr, filters = "with_hsapiens_homolog", 
                             values = TRUE, mart = martsp_ensembl)
    names(martsp_hsa_orth)[names(martsp_hsa_orth) == "ensembl_gene_id"] <- paste0(sp, 
                                                                                  "_ensembl_gene_id")
    hsa_ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")
    attr_hsa <- c("ensembl_gene_id", "entrezgene_id")
    hsa_entrez <- getBM(attr_hsa, filters = "", values = TRUE, 
                        mart = hsa_ensembl)
    martsp_hsa_orth_entrez <- merge(martsp_hsa_orth, hsa_entrez, 
                                    by.x = "hsapiens_homolog_ensembl_gene", by.y = "ensembl_gene_id", 
                                    all.x = TRUE)
    names(martsp_hsa_orth_entrez)[names(martsp_hsa_orth_entrez) == 
                                    "entrezgene_id"] <- "hsa_entrezgene"
    martsp_hsa_orth_entrez <- martsp_hsa_orth_entrez[!duplicated(martsp_hsa_orth_entrez[, 
                                                                                        paste0(sp, "_ensembl_gene_id")]), ]
    tmpfunc_hsa_entrez <- function(d) {
      if (!is.null(d)) {
        h <- as.character(martsp_hsa_orth_entrez[martsp_hsa_orth_entrez[, 
                                                                        paste0(sp, "_ensembl_gene_id")] %in% 
                                                   d$target_ensembl, "hsa_entrezgene"])
        h[h == ""] <- NA
        h <- h[!is.na(h)]
        h <- unique(h)
      }
      else {
        h <- NA
      }
      return(h)
    }
    cat("done!\n")
    out_hsa_entrez <- vector(mode = "list", length = length(out_entrez))
    names(out_hsa_entrez) <- names(out_entrez)
  }
  if (!parallelComputing) {
    out[] <- lapply(mir, function(m) {
      tmpout <- foreach(n = db, .combine = rbind, .packages = c("RCurl", 
                                                                "XML")) %do% {
                                                                  cat(paste("searching ", n, " for ", 
                                                                            m, " ...", sep = ""))
                                                                  tmp <- tmpfunc_q(i = m, j = n, mode = queryType, 
                                                                                   percentage = predictPercentage)
                                                                  cat("done!\n")
                                                                  return(tmp)
                                                                }
    })
    out_entrez[] <- foreach(o = 1:length(out)) %do% tmpfunc_lst(out[[o]])
    if (addhsaEntrez) {
      out_hsa_entrez[] <- foreach(p = 1:length(out)) %do% 
        tmpfunc_hsa_entrez(out[[p]])
    }
  }
  else {
    n_cores <- detectCores() - 1
    if (clusterType == "PSOCK") {
      cl <- makeCluster(n_cores, type = clusterType, outfile = "")
      registerDoParallel(cl)
      on.exit(stopCluster(cl))
      out[] <- foreach(m = mir, .packages = "foreach") %dopar% 
        {
          tmpout <- foreach(n = db, .combine = rbind, 
                            .packages = c("RCurl", "XML")) %do% 
            {
              cat(paste("searching ", n, " for ", 
                        m, " ...", sep = ""))
              tmp <- tmpfunc_q(i = m, j = n, mode = queryType, 
                               percentage = predictPercentage)
              cat("done!\n")
              return(tmp)
            }
        }
      out_entrez[] <- foreach(o = 1:length(out)) %dopar% 
        tmpfunc_lst(out[[o]])
      if (addhsaEntrez) {
        out_hsa_entrez[] <- foreach(p = 1:length(out)) %dopar% 
          tmpfunc_hsa_entrez(out[[p]])
      }
    }
    else if (clusterType == "FORK") {
      cat(paste("searching ", db, " ...", sep = ""))
      out[] <- mclapply(mir, FUN = function(m) {
        tmp <- foreach(n = db, .combine = rbind, .packages = c("RCurl", 
                                                               "XML")) %do% tmpfunc_q(m, n, mode = queryType, 
                                                                                      percentage = predictPercentage)
        return(tmp)
      }, mc.cores = n_cores, mc.preschedule = FALSE)
      cat("done!\n")
      out_entrez[] <- mclapply(mir, FUN = function(m) {
        tmp <- foreach(o = 1:length(out)) %do% tmpfunc_lst(out[[o]])
        return(tmp)
      }, mc.cores = n_cores, mc.preschedule = FALSE)
      if (addhsaEntrez) {
        out_hsa_entrez[] <- mclapply(mir, FUN = function(m) {
          tmp <- foreach(p = 1:length(out)) %do% tmpfunc_hsa_entrez(out[[p]])
          return(tmp)
        }, mc.cores = n_cores, mc.preschedule = FALSE)
      }
    }
  }
  if (addhsaEntrez) {
    message(paste("...all done! And entrez ID for hsa orthologs added for ", 
                  sp, ".", sep = ""))
  }
  else {
    message("...all done!")
  }
  assign(paste(objTitle, "_mrna_list", sep = ""), 
         out, envir = .GlobalEnv)
  assign(paste(objTitle, "_mrna_entrez_list", sep = ""), 
         out_entrez, envir = .GlobalEnv)
  if (addhsaEntrez) {
    assign(paste(objTitle, "_mrna_hsa_entrez_list", 
                 sep = ""), out_hsa_entrez, envir = .GlobalEnv)
  }
}





# Function to calculate GS enrichment for control data 
# data: data.frame containing FC and pvalue of the original data (is used to randmly sample values for the controls)
# rep: number of repetitions of the loop, number of control sets
# miRdata: vector containing miRNA names to sample from
# sample_n: number of miRNAs to sample
GS_controls <- function(data,rep,miRdata, sample_n,gs_file = "c2.cp.kegg.v7.2.entrez.gmt"){
  set.seed(12)
  ctrl_list <- replicate(rep, {
    tmp <- sample(miRdata, sample_n)
    ind <- sample(1:nrow(data), sample_n)
    dat_ctrl <-  cbind(tmp, data[ind,]) %>%
      setNames(c("miRNA", "FC","pvalue")) 
    
    # select target mRNAs
    rbiomirgs_mrnascan_custom(
      objTitle = "ctrl_predicted",
      mir = dat_ctrl$miRNA, sp = "hsa",
      queryType = "predicted", 
      parallelComputing = TRUE, 
      clusterType = "PSOCK"
    )
    
    # calculate GS score using logistic regression
    rbiomirgs_logistic(
      objTitle = "ctrl_predicted_mirna_mrna_iwls",
      mirna_DE = dat_ctrl, 
      var_mirnaName = "miRNA",
      var_mirnaFC = "FC", 
      var_mirnaP = "pvalue", 
      mrnalist = ctrl_predicted_mrna_entrez_list, 
      mrna_Weight = NULL, 
      gs_file = gs_file, 
      optim_method = "IWLS", 
      p.adj = "fdr", 
      parallelComputing = FALSE, 
      clusterType = "PSOCK"
    )
    
    # add the mean number of genes targeted by the 10 miRNA set
    tmp <- lapply(c(1:length(ctrl_predicted_mrna_entrez_list)),function(x){
      ctrl_predicted_mrna_entrez_list[[x]] %>% length()
    }) %>% unlist() 
    # calculate mean of the genes and make sure lists from miRNAs without target genes are excluded 
    mean(tmp[tmp != 1])
    
    list(number_target_genes = mean(tmp[tmp != 1]), 
         res_GS = ctrl_predicted_mirna_mrna_iwls_GS)
  })
}  




# calculate bias (as percentage of randomly enriched pathways and mean of number of genes targeted by miRNAs)
pathway_ctrl_summary <- function(ls,n=n){
  counts <- sapply(c(1:n), function(x){
    tmp <- as.data.frame(ls[,x]$res_GS) %>% filter(adj.p.val < 0.05)
    tmp$GS
  }) %>% unlist() %>% table() 
  
  prob <- counts/n
  
  target_genes <- sapply(c(1:n), function(x){
    as.data.frame(ls[,x]$number_target_genes) 
  }) %>% unlist() %>% mean()
  
  list(bias = prob[order(desc(prob))],
       mean_targets = target_genes)
  
}